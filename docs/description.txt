Popis programu (11.1.2021):

Program dostane na vstupu seznam cest k souborům s obrázky nebo videi, která chce uživatel analyzovat. Soubory se analyzují postupně.

Instance třídy "video_processor" se pokusí otevřít příslušný soubor (jako obrázek nebo video), pro testovací účely podle cesty souboru nastaví parametry fps, číslo snímku, ve kterém začne hledat atleta a pozici středu těla atleta. Pokud je soubor obrázek, předá tento jediný obrázek instanci třídy "body_detector" ke zpracování ve funkci "detect". Pokud je soubor video, prochází jeho snímky postupně a předává je stejně jako v případě obrázku, dokud nezpracuje všechny snímky nebo dokud nedojde k chybě.

Instance třídy "body_detector" inicializuje pro každý soubor (video nebo obrázek) zvlášť. Funkce "detect" dostane na vstupu snímek, zkontroluje, jestli je počet již zpracovaných snímků menší než parametr určující začátek detekce atleta, v takovémto případě snímek zahodí. Pokud právě zpracovává snímek, ve kterém má detekce atleta začít, použije funkci cv::HOGDescriptor::detectMultiScale pro nalezení postav ve snímku. Podle parametru pozice atleta vybere příslušnou postavu a použije ji při inicializaci trackeru cv::TrackerCSRT. Pokud se zpracovává pozdější snímek, trasuje se objekt, který program inicializoval dříve.

Fáze rozběhu a fáze skoku se zpracovává mírně odlišně.

Ze začátku se snímek nachází ve fázi rozběhu, program použije funkci cv::TrackerCSRT::update, která aktualizuje pozici obdélníku ohraňučíjícího postavu atleta. Tento obdélník si uložím. Program v této fázi pracuje s instancí třídy "movement_analyzer", která zkoumá pohyb středu obdélníku ohraňučíjícího postavu atleta vůči pozadí videa (vertikální i horizontální). Funkce movement_analyzer::update zajišťuje, že trasuji část pozadí videa, která se celá nachází uvnitř právě zpracovávaného snímku, v případě, že se část pozadí dostala mimo záběr, vybere se nová tak, že se posune těsně za atleta a nastaví se jí velikost atletova obdélníku (tedy při pohledu ze strany se posune nalevo od atleta, běží-li atlet doprava), navíc se zaktualizuje vzdálenost středu nové části pozadí od původní části (úplně první, kterou program inicializoval). Část pozadí trasuje tracker cv::TrackerCSRT, při zpracování každého snímku se tedy zavolá funkce cv::TrackerCSRT::update. Program spočítá vertikální a horizontální vzdálenost atleta od původní části pozadí (za pomoci současné polohy trasované části pozadí). Použije se vzorec `new_offset = delta + athlete_position - background_position`, kde delta je vzdálenost součsné polohy atleta od původní části pozadí. new_offset si uložím. "movement_analyzer" ještě zkoumá, zda nezačal skok. Zkoumá průměrný vertikální rozdíl po sobě jdoucích hodnot `new_offset`. Všech n doposud spočítaných hodnot se rozdělí na dvě části, prvních n-6 a posledních 6. Pro každou se spočítá průměrná vertikální změna dvou po sobě jdoucích hodnot `(last - first) / (k - 1)`, kde last je hodnota posledního prvku, first prvního a k počet prvků dané části. Nyní se kontroluje, jestli je rozdíl `(last_part_offset - first_part_offset) * (person_height / frame_height) / frame_height` menší než hodnota `alpha`, kde alpha je pevná konstanta. Nerovnost reprezentuje to, že se v posledních šesti snímcích atlet začíná pohybovat vzhůru vůči směru rozběhu, v potaz bere relativnívelikost atleta na snímku a rozlišení snímku. Pokud se nerovnost splní, program předpokládá, že začal skok a následující snímky bude zpracovávat jinak.

Od začátku fáze skoku se snímek používaný pro trasování atleta postupně otáčí po dobu 0.8 sekundy o 180 stupňů. Úhel, o který se má i-tý snímek skoku otočit se počítá ve stupních jako `180 * current_frame / fps / 0.8`, tento úhel se ještě vynásobí hodnotou -1, pokud atlet na videu směrem doprava, tím se snímek otočí po směru hodinových ručiček. Cílem tohoto otáčení je přesnější detekce atleta ve fázi skoku, program se snaží atleta trasovat tak, aby jeho nohy byly na snímku vždy níž než hlava. Toto otáčení a následné trasování řeší instance třídy "vault_body_detector".

Aktualizace (19.1.2021):

Podrobná detekce atleta se provádí po nalezení obdélníku, ve kterém se atlet vyskytuje. Použije se cv::dnn::Net, kterou načte ze souborů. Při zpracování snímku se vytvoří instance třídy "person", která se o podrobnou detekci stará, dostane načtenou síť, číslo snímku a pozice rohů obdélníku ve snímku. Hlavní funkčnost je reprezentovaná funkcí "detect", která nalezne důležité body těla atleta (MPII), tyto body poté z výsledku, který dostane od sítě, převede tak, aby jejich hodnota odpovídala pozici ve snímku. Tato transformace se počítá pro bod `p` jako `tl + p'.x * (tr - tl) / width + p'.y * (bl - tl) / height`, kde `tl`, `tr` a `bl` jsou pozice rohů obdélníku ve snímku (levý horní, pravý horní a levý dolní), `width` a `height` je šířka a výška obdélníku a `p'` je pozice bodu `p`, který jsem dostal jako výsledek ze sítě, přeškálovaná tak, aby odpovídala pozici v obdélníku, který není nijak otočen a jehož levý horní roh má souřadnice (0,0). Hodnoty těchto bodů jsou uloženy ve vektoru, dále mám pole, které určuje dvojice bodů, které jsou spojeny - například (zápěstí, loket).

Vektor bodů a pole dvojic mám v plánu indexovat pomocí typu "enum:int", abych k jednotlivým bodům mohl v kódu přistupovat podle jejich jmen.

Tato implementace narážela na problém, že obdélník ohraničující atleta neobsahuje jeho celé tělo, proto před použitím obdélníku jeho velikost zvětším tak, aby nový střed odpovídal středu starého obdélníku a jeho strany zvětším 1.8x. Toto provedu při trasování atleta v instanci "vault_body_detector", ze kterých vrátím i větší výřez snímku, ale pro zachování přesnosti trasování nechám obdélník ohraničující tělo atleta malý. Musím také hlídat, abych obdélník atleta nezvětšil příliš - aby se vešel do snímku, k tomuto účelu obsahuje instance "vault_body_detector" proměnnou, která říká, jestli jsem poslední obdélník zvětšil (tedy jestli se vejde do snímku), v tomto případě ho poté i znovu zmenším a řeším její hodnotu i při získávání bodů z výsledku detekovací sítě.

Síť nefunguje dobře na malých obdélnících. Našel jsem tento příspěvek "https://stackoverflow.com/questions/52426462/neural-network-input-size-in-opencvdnn", který říká, že velikost obdélníku je určena v ".prototxt" souboru, ze kterého načítám síť. Můj soubor tuto velikost neurčuje, získává se za běhu programu. Zvětšení obdélníku při řešení problému popsaného v minulém ostavci pomohlo.

Aktualizace (21.1.2021):

Předělal jsem strukturu programu tak, aby instance "person" odpovídala jedné osobě po dobu celého videa. Pomocí této změny věřím, že vyřeším detekci atleta ve videu bez závislosti na vstupních parametrech snáze. Chtěl bych trasovat každý obdéník, který mi najde původní detekce a za atleta budu považovat ten obdélník, který vydrží v záběru nejdéle, takto ho budu z časových důvodů trasovat jen jako obdélník, podrobnou detekci spustím při druhém průchodu videem. 



















