\chapter{Realizace}

\section{Zvolené prostředky}
\label{sec:prostredky}

Pro potřeby analýzy videa jsem použil jazyk C++ a~knihovnu OpenCV. Jelikož je analýza výpočetně náročná, dal jsem z~rychlostních důvodů přednost jazyku C++ před jazykem Python. Také mám s~jazykem C++ více zkušeností.

Pro zobrazení parametrů v~grafické podobě jsem se rozhodl využít Matplotlib. Pro využití této knihovny není potřeba znát speciální syntaxi, základní znalosti Pythonu jsou dostačující. Jelikož je knihovna Matplotlib určena pro Python, je snadné napsat skript, který nejen vygeneruje grafy, ale také zpracuje data, která se mají zobrazit.

Program lze spustit na počítači s~Unixovým operačním systémem.




\section{Souřadné systémy}

Nyní popíšu konverze mezi souřadnými systémy.

Souřadné systémy snímku a~videa jsou jen posunuté o~vzájemnou pozici levého horního rohu snímku a~pozadí v~prvním snímku. Tudíž jejich konverzi reprezentuje operace posunutí.

Konverze mezi souřadným systémem videa a~prostoru je složitější. Jednotka systémů je stejná, tudíž škálování není třeba provádět. První složky bodů v~obou systémech spolu korespondují. Druhá složka bodu v~souřadném systému videa odpovídá třetí složce bodu v~prostoru. Tuto konverzi používám jen pro určení pozice kloubů těla atleta.

Je třeba zohlednit směr rozběhu atleta. Pokud běží doleva, musím převrátit hodnotu první složky. Pokud běží doprava, hodnotu první složky nechám stejnou.

Hodnotu druhé složky nastavím na $0$. Odhad pozice kloubu v~tomto směru je problematický, jelikož se atlet při skoku otáčí podél své osy, tudíž její implementaci ponechám do budoucích verzí programu.

Hodnotu třetí složky v~prostoru získám převrácením druhé složky bodu v~souřadném systému videa.

Výsledkem tohoto postupu je posunutý prostor, musím ho tedy posunout s~využitím pozice kotníku odrazové nohy v~momentu odrazu.

Konverzi bodu kostry $(x',y')$ v~souřadném systému videa do prostoru lze reprezentovat takto:
\begin{alignat*}{3}
&\text{Při běhu doprava:} &\qquad (x,y,z)&=(x',&0,-y')-d. \\
&\text{Při běhu doleva:} &\qquad (x,y,z)&=(-x',&0,-y')-d.
\end{alignat*}
$d$ značí pozici kotníku odrazové nohy při odrazu v~prostoru.

Pozici kotníku odrazové nohy získám až po analýze parametrů, tudíž při analýze pracuji s~posunutým prostorem. Na vliv většiny parametrů to vliv nemá, některé poté musím spočítat znovu (například výšku boků).




\section{Struktura programu}

[SCHÉMA PROGRAMU A POPIS TŘÍD]




\section{Vstup programu}

Programu jsou při jeho spuštění předány parametry. Parametry specifikují mód, ve kterém si uživatel přeje program spustit a~obsahují cesty k~souborům, které má program zpracovat.

O~zpracování parametrů se stará soubor \texttt{main.cpp}, který definuje vstupní bod aplikace a~volá metody třídy \texttt{video\_processor}, která zpracuje video, případně model, a~výsledek předá k~analýze.




\section{Analýza videa}

\subsection{Zpracování videa}

Zpracování videa má na starosti třída \texttt{video\_processor}. 

Video načtu s~použitím třídy \texttt{cv::VideoCapture}. Z~videa získám hodnotu frekvence snímků a~jednotlivé snímky videa uložím při průchodu do vektoru $3$-rozměrných matic \texttt{cv::Mat}, které reprezentují snímky videa.

Z~důvodu časové náročnosti videí s~velikým rozlišením zmenším každý snímek metodou \texttt{cv::resize}. Výsledný snímek videa má rozlišení 720p. Při zpracování videa na šířku je výška videa 720\,\rm pixelů, šířka se změní, aby byl poměr stran snímku zachován. Při zpracování videa na výšku je šířka výsledného snímku 720\,\rm pixelů, výška se změní v~odpovídajícím poměru.

Vzorce pro změnu velikosti snímku videa s~rozlišením $x'\times y'$ na výsledné rozlišení $x\times y$, reprezentující 720p jsou následující:
\begin{alignat*}{3}
&\text{Na výšku:}   &\qquad (x, y) &= (720 * x' / y',  &720) \\
&\text{Na šířku:}   &\qquad (x, y) &= (720,            &720 * y' / x')
\end{alignat*}
První složka udává šířku snímku, druhá výšku.









\section{Analýza modelu}

\subsection{}



\subsection{Zpracování videa}




\subsection{Konverze souřadných systémů}
\label{ssec:konverze}



\section{tmp}

Ve snímku, ve kterém detekuji objekt, vyberu část snímku, ve které se objekt, jehož pohyb určuji, nenachází. Tím získám pozadí, jehož pozice je statická v~průběhu celého videa. Pozici objektu budu následně vztahovat ke středu této oblasti. Určení pozice je v~prvním snímku snadné, lze ji vyjídřit výrazem $p_0=o_0-b_0$, kde $o_0$~je pozice středu objektu ve snímku, $b_0$~pozice středu pozadí ve snímku a $p_0$~výsledná pozice objektu vůči pozadí. Také určím pozici $t_0$ levého horního rohu snímku vůči středu pozadí, ta je rovna $t_0=-b_0$. Na základě pozice levého horního rohu snímku lze snadno určit pozici objektu: $p_0=t_0+o_0=o_0-b_0$.

Při přechodu do následujícího snímku získám pomocí trackerů pozici objektu a~pozadí. Podle pozice pozadí v~nyní zpracovávaném snímku získám pozici levého horního snímku vůči pozadí, jelikož se pozadí nepohybuje, reprezentuje tato hodnota pozici levého horního rohu snímku vůči středu původního pozadí. Tuto hodnotu si označím jako $t_1$. Podle její hodnoty snadno určím novou pozici objektu, dojdu k~ní výrazem $p_1=t_1+o_1$, kde $o_1$~je pozice středu objektu v~nyní zpracovávaném snímku a $p_1$~výsledná pozice vůči původnímu středu pozadí.

V~průbehu videa pravděpodobně dojde k~momentu, kdy se pozorovaná část pozadí dostane mimo záběr. V~tuto chvíli aktualizuji pozadí jako novou oblast pozadí právě zpracovávaného snímku. Na základě vzájemné pozice původního a~aktualizovaného pozadí určím pozici aktualizovaného pozadí vůči původnímu pozadí, označím si ji jako $d$. Pozice objektů v~následujících snímcích budu vztahovat k~aktualizovanému pozadí, ale k~výsledné pozici přičtu $d$. Při další aktualizaci pozadí zvýším $d$ o~posun nového pozadí vůči stávajícímu. [OBRÁZEK znázorňující výpočty]

Tyto výpočty vycházejí z~vlastností souřadného systému snímku, který popisuji v~sekci \ref{ssec:konverze}.

\section{tmp3}

Pro přesnost je potřeba vyfiltrovat snímky, ve kterých nedochází ke kroku, příkladem je chvíle po odrazu, při níž atlet švihá odrazovou nohou dopředu. Odrazová noha se tedy po odrazu pohybuje vzhůru a~následně dolů, což může být z~hlediska algoritmu vnímáno jako krok. Snímek označím za krok jen v~případě, že je noha dostatečně nízko. Také je potřeba ohlídat nepřesné detekce kostry, vertikální pohyb nohy tedy musí překročit jistou hodnotu, aby byl snímek považován za moment došlapu, případně odrazu. [OBRÁZEK pohybu nohou s ukázkou švihu při skoku]











